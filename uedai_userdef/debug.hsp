#ifndef IG_UEDAI_DEBUG_HSP
#define IG_UEDAI_DEBUG_HSP

/*
%dll
uedai_userdef/debug.hsp

%group
デバッグ支援
%*/

#undef logmes
;#undef assert

#ifdef _DEBUG
#module __debug

//ログを保存するフォルダへのパス
#define global Dir_LogFilePath (dir_mydoc + "/hsp_debug_log.txt")

#uselib "winmm.dll"
#cfunc timeGetTime "timeGetTime"

/*
%index
declvar
変数を初期化済みとして宣言する
%*/
#define global declvar(%1) if (0) { dim %1 }

/*
%index
__HERE__
スクリプト位置の文字列リテラル
%*/
#define global __HERE__ ("#" + __LINE__ + " " + __FILE__)

/*
%index
dbgstr
式とその値の文字列
%prm
(expr)
%*/
#define global ctype dbgstr(%1) ({"%1 = "} + (%1))

/*
%index
dbgpair
式のペアとその値の文字列
%prm
(expr_lhs, expr_rhs)
%*/
#define global ctype dbgpair(%1, %2) ({"(%1,%2) = ("} + (%1) + ", " + (%2) + ")")

/*
%index
dbghex
式とその数値(16進数表記)の文字列
%prm
(expr_int)
%*/
#define global ctype dbghex(%1)  strf({"%1 = 0x%%08X"}, (%1))

/*
%index
dbgchar
式とその文字の文字列
%prm
(expr_char)
%*/
#define global ctype dbgchar(%1) strf({"%1 = '%%c'"}, (%1))

/*
%index
dbgcode
デバッグ時か否かの条件演算式
%prm
(x_debug, x_release)
%inst
デバッグ時は x_debug に、リリース時は x_release に展開される。
%*/
#define global ctype dbgcode(%1, %2) (%1)

/*
%index
assert_sentinel
絶対に実行されないことを言明
%inst
assert の一種。default 節など、分岐の流れから絶対に実行されないところに書く。
*/
#define global assert_sentinel logerr "assert sentinel", __HERE__ : assert : end 1

/*
%index
var_type_name
型タイプ値から型名を取得する
%prm
(type_index)
%*/
#defcfunc var_type_name int type,  local name, local hvpPtr, local hvp, local prms
	prms = type
	hvpPtr = callfunc(prms, exinfo_at@__debug(25), 1) //HspFunc_getproc
	if ( hvpPtr != 0 ) {
		dupptr hvp, hvpPtr, 20
		if ( hvp(3) != 0 ) {
			dupptr name, hvp(3), 1, vartype("str")
			return name
		}
	}
	assert
	return ""
	
#defcfunc exinfo_at@__debug int idx,  local ctx, local exinfo
	mref ctx, 68
	dupptr exinfo, varptr(ctx(12)), 188
	return exinfo(idx)

//------------------------------------------------
// 出力設定
//------------------------------------------------
#enum global LogMode_Default = 0 //改行区切り
#enum global LogMode_Xml         //書式付き
#enum global LogMode_Max

#enum global LogLevel_Default = 0 //最低
#enum global LogLevel_Notice  = 10
#enum global LogLevel_Warn    = 30
#enum global LogLevel_Error   = 0x7FFF //実際にエラーを起こす

#define global LogEcho_None   0x000
#define global LogEcho_DbgWnd 0x001
#define global LogEcho_File   0x002
#define global LogEcho_All    0xFFF

#deffunc init@__debug
	stt_logPath  = Dir_LogFilePath
	stt_logIndex = 0
	stt_logMode  = LogMode_Default
	stt_logEcho  = LogEcho_All
	stt_logLevel = LogLevel_Default
	sdim  stt_logStr,  4096 //ログメッセージを代入するための一時バッファ
	bsave stt_logPath, stt_logStr, 0 // 上書きして前のデータを削除
	return
	
/*
%index
logmes@__debug
ログ出力
%prm
msg [, log_level, there]
%inst
デバッグウィンドウ、およびログファイルにメッセージ msg を追記する。
%*/
#define global logmes(%1 = "", %2 = LogLevel_Default, %3 = __HERE__) logmes@__debug str(%1), (%2), (%3)
#deffunc logmes@__debug str msg,  int level, str there,  local len
	if ( level < stt_logLevel ) { return }
	
	//デバッグウィンドウに送る
	if ( stt_logEcho & LogEcho_DbgWnd ) {
		switch ( level )
			case LogLevel_Warn:
				logmes@hsp "[WARNING] " + there
				swbreak
			case LogLevel_Error:
				logmes@hsp "[ERROR!] " + there
				swbreak
		swend
		logmes@hsp msg
	}
	
	//ファイルに書き込む
	if ( stt_logEcho & LogEcho_File ) {
		switch ( stt_logMode )
			case LogMode_Default:
				stt_logStr = msg + "\n"
				swbreak
			case LogMode_Xml:
				stt_logStr = "<log source=\"" + there + "\" time=\"" + timeGetTime() + "\"><![CDATA[" + msg + "]]></log>\n"
				swbreak
		swend
		len = strlen(stt_logStr)
		bsave stt_logPath, stt_logStr, len, stt_logIndex
		stt_logIndex += len
	}
	return
	
/*
%index
logwarn
ログ出力 (警告)
%prm
msg
%*/
#define global logwarn(%1 = "", %2 = __HERE__) logmes@__debug (%1), LogLevel_Warn, (%2)

/*
%index
logerr
ログ出力 (エラー)
%prm
msg
%inst
LogLevel_Error でログ出力(logmes@__debug)し、エラー終了する。
%*/
#define global logerr(%1 = "", %2 = __HERE__) logmes@__debug (%1), LogLevel_Error, (%2)

/*
%index
logvar
変数をログ出力
%prm
v [, log_level, there]
%inst
変数とその名前を logmes@__debug する。通常の文字列化(str)よりも詳しく、かつ見やすく出力される。
%*/
#define global logvar(%1, %2 = LogLevel_Default, %3 = __HERE__) logvar@__debug (%1), {"%1"}, (%2), (%3), (%4)
#deffunc logvar@__debug var value, str _varname,  int level, str there,  local varname
	varname = _varname : varname = strtrim(varname)
	
	switch ( vartype(value) )
		case vartype("str"):
			if ( instr(value, 0, "\n") >= 0 ) { //複数行文字列の場合
				logmes@__debug strf("%s = {\"%s\"}", varname, value), level, there
			} else {
				logmes@__debug strf("%s = %s", varname, value), level, there
			}
			swbreak
			
		case vartype("double"):
			logmes@__debug strf("%s = %.16f", varname, value), level, there
			swbreak
			
		case vartype("int"):
			logmes@__debug strf("%s = %d\t(0x%08X)", varname, value, value), level, there
			swbreak
			
		default:
			logmes@__debug strf("%s: type %s", varname, var_type_name(vartype(value))), level, there
			swbreak
	swend
	return

/*
%index
logmode
logmes@__debug の出力形式を指定する
%prm
mode
%*/
#deffunc logmode int mode
	if ( stt_logMode != mode ) {
		logmes@__debug "log mode has changed: " + stt_logMode + " -> " + mode + ".", LogLevel_Notice, "DEBUG"
		stt_logMode = mode
	}
	return
	
/*
%index
logecho
logmes@__debug の送信先を指定する
%prm
flags
%inst
次の2つのビットフラグの組み合わせで指定する。
LogEcho_DbgWnd: デバッグウィンドウ
LogEcho_File: ログファイル
%*/
#deffunc logecho int flags
	stt_logEcho = flags
	return
	
/*
%index
dbgchk_T
言明つきの式
%prm
(expr, cond)
%inst
式 expr の値に関する条件 cond をチェックする。expr を返す。
もし cond が不成立なら、警告を出力する(logwarn)。

式 cond のなかでは、システム変数 dbgchkValue = expr が使用できる。

T は、expr が str 型なら s、int 型なら i、double 型なら d。
%*/
#define global ctype dbgchk_s(%1, %2) dbgchkImpl_s(dbgchkSet_s@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)
#define global ctype dbgchk_d(%1, %2) dbgchkImpl_d(dbgchkSet_d@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)
#define global ctype dbgchk_i(%1, %2) dbgchkImpl_i(dbgchkSet_i@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)

#define ctype FTM_dbgchkImpl(%1) \
	if ( b == 0 ) { \
		logwarn "dbgchk(%1) error\n\texpr: " + x + "\n\tvalue = " + code_value + "\n\tcondition: " + code_condition, there :\
	} :\
	return x ://

#define global dbgchkValue stt_dbgchkValue@__debug

#defcfunc dbgchkSet_s@__debug str x
	dbgchkValue = x : return x
#defcfunc dbgchkSet_d@__debug double x
	dbgchkValue = x : return x
#defcfunc dbgchkSet_i@__debug int x
	dbgchkValue = x : return x
	
#defcfunc dbgchkImpl_s str x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(str)
#defcfunc dbgchkImpl_d double x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(double)
#defcfunc dbgchkImpl_i int x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(int)

#undef FTM_dbgchkImpl

#global

	init@__debug

#else

#define global logmes(%1 = "", %2 = 0, %3 = "", %4 = 0) :
;#define global assert(%1 = 0) :

#define global ctype var_type_name(%1) ""
#define global logmode(%1 = 0) :
#define global loglev(%1 = 0) :
#define global logvar(%1) :
#define global logwarn(%1 = "") :
#define global logerr(%1 = "") :
#define global logecho(%1 = 0) :

#define global __HERE__ ""
#define global declvar(%1) :
#define global ctype dbgstr(%1) ""
#define global ctype dbgpair(%1, %2) ""
#define global ctype dbghex(%1) ""
#define global ctype dbgchar(%1) ""
#define global ctype dbgcode(%1, %2) (%2)
#define global ctype dbgchk_s(%1, %2) (%1)
#define global ctype dbgchk_d(%1, %2) (%1)
#define global ctype dbgchk_i(%1, %2) (%1)
#define global assert_sentinel end 1 //abort

#endif

#endif
